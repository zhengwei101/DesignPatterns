# 设计模式

> Design Patterns

"每个模式描述了一个在我们周围不断重复发生的问题，以及该问题解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。" ————Christopher Alexander

设计模式主要描述的是类与相互通信的对象之间的组织关系，包括它们的角色、职责、协作方式等方面。

## 创建型设计模式

> Creational Patterns

将对象的部分创建工作延迟到子类或其他对象。
  
## 结构型设计模式

> Structural Patterns

通过类继承或对象组合获得更灵活的结构。

## 行为型设计模式

> Behavioral Patterns

通过类继承或对象组合来划分类与对象间的职责。

## 从封装变化角度来对模式进行分类

### 组件协作

现代软件专业分工之后的第一个结果是“框架与应用程序的划分”。

“组件协作”模式通过延迟绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。

典型模式

- Template Method
- Observer / Event
- Strategy

### 单一职责

在软件组件的设计中，如果责任划分不清晰，使用继承得到的结果往往会因需求的变化导致子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。

典型模式

- Decorator
- Bridge

### 对象创建

通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。

"new"会带来具体类的依赖，所以要想办法绕开。

典型模式

- Factory Method
- Abstract Factory
- Prototype
- Builder （不常用）

### 对象性能

面向对象很好地解决了“抽象”的问题，但是必不可免的要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况下，面向对象所带来的成本必须谨慎处理。

典型模式

- Singleton
- Flyweight

### 接口隔离

在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题，甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。

典型模式

- Facade
- Proxy
- Mediator（不常用）
- Adapter

### 状态变化

在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案。

典型模式

- Memento（不常用）
- State

### 数据结构

常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。

典型模式

- Composite
- Iterator （不常用）
- Chain of Resposibility （不常用）

### 行为变化

在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化”模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。

典型模式

- Command （不常用，C++有更好用的function object）
- Visitor

### 领域规则

在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。

典型模式

- Interpreter （不常用）

## 类模式与对象模式

- 类模式处理类与子类的静态关系
- 对象模式处理对象间的动态关系

## 应对变化，提高复用

现代软件设计的特征是“需求的频繁变化”，设计模式的要点是寻找变化点，然后在变化点处应用设计模式，从而更好的应对需求的变化。

什么时候，什么地点应用设计模式，比理解设计模式结构本身更为重要。

## 采用 Refactoring to Patterns 来使用设计模式

设计模式的应用不宜先入主，没有一步到位的设计模式，一上来就使用设计模式是对设计模式的最大误用。

## 重构关键技法

- 静态 -> 动态
- 早绑定 -> 晚绑定
- 继承 -> 组合
- 编译时依赖 -> 运行时依赖
- 紧耦合 -> 松耦合

## 经验之谈

- 不要为模式而模式
- 关注抽象类和接口
- 理清变化点和稳定点
- 审视依赖关系
- 要有Framwork和Application的区隔思维
- 良好的设计是演化的结果

## 大部分设计模式中的对象模型

```c++
class A 
{
    B *pB; //B实际指向的是B的子类的对象
};

```
